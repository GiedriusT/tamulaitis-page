import fs from 'fs';
import path from 'path';
import CryptoJS from 'crypto-js';

const SECRETS_OUTPUT_FILE = './src/utils/secrets.ts';

interface EncryptionResult {
  encryptedText: string;
  iv: string;
  key: string;
}

interface SecretData extends EncryptionResult {
  title: string;
  slug : string;
  sourceFilename: string;
}

const sourceFolder = process.argv[2];
if (!sourceFolder) {
  console.error('Directory path missing! It should be provided as first argument.');
  process.exit(1);
}
if (fs.existsSync(sourceFolder) === false) {
  console.error(`Directory ${sourceFolder} does not exist!`);
  process.exit(1);
}

function encryptText(text: string, key: string, ivString?: string): EncryptionResult {
  const iv = ivString ? CryptoJS.enc.Hex.parse(ivString) : CryptoJS.lib.WordArray.random(2);
  const ciphertext = CryptoJS.AES.encrypt(text, key, { iv });
  return {
    encryptedText: ciphertext.toString(),
    iv: iv.toString(),
    key,
  };
}

function generateSecretsFileContent(secrets: SecretData[]): string {
  const lines: string[] = [];
  secrets.forEach((secret) => {
    lines.push(`  // ${secret.title}`);
    lines.push(`  ${JSON.stringify(secret.encryptedText)},`);
  });
  let fileContents = '/* eslint-disable @typescript-eslint/quotes */\n';
  fileContents += '// Secrets file auto generated by secgen.ts\n\n';
  fileContents += 'const secrets: string[] = [\n';
  fileContents += lines.join('\n');
  fileContents += '\n];\n\n';
  fileContents += 'export default secrets;\n';
  return fileContents;
}

function metadataFilename(sourceFilename: string): string {
  return sourceFilename.replace('.md', '.json');
}

function getSecretMetadata(sourceFilename: string): SecretData | null {
  const metadataFilePath = path.join(sourceFolder, metadataFilename(sourceFilename));
  if (fs.existsSync(metadataFilePath) === false)
    return null;

  const metadataString = fs.readFileSync(path.join(sourceFolder, metadataFilename(sourceFilename)), 'utf8');
  return JSON.parse(metadataString.toString()) as SecretData;
}

const secrets: SecretData[] = [];

console.log('Generating secrets...');
const files = fs.readdirSync(sourceFolder).filter((filename) => filename.endsWith('.md'));
files.forEach((filename) => {
  const inputFilePath = path.join(sourceFolder, filename);
  const fileContents = fs.readFileSync(inputFilePath, 'utf8');
  const firstLineEnd = fileContents.indexOf('\n');
  const title = fileContents.substr(0, firstLineEnd).trim().replace(/^(#+)\s*/, '');
  const key = filename.replace('.md', '').split('_')[1];

  const existingMetadata = getSecretMetadata(filename);

  const encryptionResult = encryptText(fileContents, key, existingMetadata?.iv);

  const secretData: SecretData = {
    title,
    slug: `${encryptionResult.key}-${encryptionResult.iv}`,
    sourceFilename: filename,
    ...encryptionResult,
  };

  secrets.push(secretData);

  const outputFilename = path.join(sourceFolder, metadataFilename(filename));
  fs.writeFileSync(outputFilename, JSON.stringify(secretData, null, 2));
  console.log(`From ${filename}`);
});

const secretsFileContent = generateSecretsFileContent(secrets);
fs.writeFileSync(SECRETS_OUTPUT_FILE, secretsFileContent);
console.log('File secrets.ts generated!');
